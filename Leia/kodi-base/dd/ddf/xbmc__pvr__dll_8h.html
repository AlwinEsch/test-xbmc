<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Kodi Documentation: xbmc_pvr_dll.h File Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../Thumbnail-symbol-whitebg-small.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Kodi Documentation<span id="projectnumber">&#160;18.0</span>
   </div>
   <div id="projectbrief">Kodi is an open source media player and entertainment hub.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('dd/ddf/xbmc__pvr__dll_8h.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle"><div class="title">xbmc_pvr_dll.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="../../db/d18/xbmc__addon__dll_8h.html">xbmc_addon_dll.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html">xbmc_pvr_types.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">PVR add-on methods</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p >Functions that the <a class="el" href="../../dc/dc4/namespace_p_v_r.html">PVR</a> client add-on must implement, but some can be empty.</p>
<p >The 'remarks' field indicates which methods should be implemented, and which ones are optional. </p>
</div></td></tr>
<tr class="memitem:aac0ab5d23b401e2baa76c8ab3a031964"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#aac0ab5d23b401e2baa76c8ab3a031964">GetAddonCapabilities</a> (<a class="el" href="../../db/dd7/struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html">PVR_ADDON_CAPABILITIES</a> *pCapabilities)</td></tr>
<tr class="separator:aac0ab5d23b401e2baa76c8ab3a031964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a134f4ea0311a2b5a43cf386e26320b87"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#a134f4ea0311a2b5a43cf386e26320b87">GetBackendName</a> (<a class="el" href="../../d9/d67/emu__msvcrt_8h.html#acee5409d1d6b16f3905a59b0db1bd14f">void</a>)</td></tr>
<tr class="separator:a134f4ea0311a2b5a43cf386e26320b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e3fc6e343eb4007e3c994bfd701891a"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#a9e3fc6e343eb4007e3c994bfd701891a">GetBackendVersion</a> (<a class="el" href="../../d9/d67/emu__msvcrt_8h.html#acee5409d1d6b16f3905a59b0db1bd14f">void</a>)</td></tr>
<tr class="separator:a9e3fc6e343eb4007e3c994bfd701891a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bfc06985e780593bcaadccc4ef58f04"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#a4bfc06985e780593bcaadccc4ef58f04">GetConnectionString</a> (<a class="el" href="../../d9/d67/emu__msvcrt_8h.html#acee5409d1d6b16f3905a59b0db1bd14f">void</a>)</td></tr>
<tr class="separator:a4bfc06985e780593bcaadccc4ef58f04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4ef92c952f4f98fed7031d5c14dafee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#aa4ef92c952f4f98fed7031d5c14dafee">GetDriveSpace</a> (long long *iTotal, long long *iUsed)</td></tr>
<tr class="separator:aa4ef92c952f4f98fed7031d5c14dafee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98ea5b651445ba01caeca6b411ac33cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#a98ea5b651445ba01caeca6b411ac33cb">CallMenuHook</a> (const <a class="el" href="../../d4/d40/struct_p_v_r___m_e_n_u_h_o_o_k.html">PVR_MENUHOOK</a> &amp;menuhook, const <a class="el" href="../../db/d43/struct_p_v_r___m_e_n_u_h_o_o_k___d_a_t_a.html">PVR_MENUHOOK_DATA</a> &amp;item)</td></tr>
<tr class="separator:a98ea5b651445ba01caeca6b411ac33cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">PVR EPG methods</div></td></tr>
<tr><td colspan="2"><div class="groupText"><dl class="section remark"><dt>Remarks</dt><dd>Only used by Kodi if bSupportsEPG is set to true. </dd></dl>
</div></td></tr>
<tr class="memitem:a357fd3786812f4de703de6609d59120e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#a357fd3786812f4de703de6609d59120e">GetEPGForChannel</a> (<a class="el" href="../../da/d77/_addon_base_8h.html#a8e2f99776bc8f0a43bccbfd988059d6a">ADDON_HANDLE</a> handle, const <a class="el" href="../../d4/d7c/struct_p_v_r___c_h_a_n_n_e_l.html">PVR_CHANNEL</a> &amp;channel, time_t iStart, time_t iEnd)</td></tr>
<tr class="separator:a357fd3786812f4de703de6609d59120e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb2d0ede864295ba8255c19243475b3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#aeb2d0ede864295ba8255c19243475b3c">IsEPGTagRecordable</a> (const <a class="el" href="../../d0/d91/struct_e_p_g___t_a_g.html">EPG_TAG</a> *tag, bool *bIsRecordable)</td></tr>
<tr class="separator:aeb2d0ede864295ba8255c19243475b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af09355268dfa3701f266ee35ddb0adb7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#af09355268dfa3701f266ee35ddb0adb7">IsEPGTagPlayable</a> (const <a class="el" href="../../d0/d91/struct_e_p_g___t_a_g.html">EPG_TAG</a> *tag, bool *bIsPlayable)</td></tr>
<tr class="separator:af09355268dfa3701f266ee35ddb0adb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29d80039472e2fd0c38b7c04561447ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#a29d80039472e2fd0c38b7c04561447ba">GetEPGTagEdl</a> (const <a class="el" href="../../d0/d91/struct_e_p_g___t_a_g.html">EPG_TAG</a> *epgTag, <a class="el" href="../../d2/d9e/struct_p_v_r___e_d_l___e_n_t_r_y.html">PVR_EDL_ENTRY</a> edl[], int *size)</td></tr>
<tr class="separator:a29d80039472e2fd0c38b7c04561447ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace909572aa272c30adcb46d9f64b3157"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#ace909572aa272c30adcb46d9f64b3157">GetEPGTagStreamProperties</a> (const <a class="el" href="../../d0/d91/struct_e_p_g___t_a_g.html">EPG_TAG</a> *tag, <a class="el" href="../../d2/d18/struct_p_v_r___n_a_m_e_d___v_a_l_u_e.html">PVR_NAMED_VALUE</a> *properties, unsigned int *iPropertiesCount)</td></tr>
<tr class="separator:ace909572aa272c30adcb46d9f64b3157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">PVR channel group methods</div></td></tr>
<tr><td colspan="2"><div class="groupText"><dl class="section remark"><dt>Remarks</dt><dd>Only used by Kodi if bSupportsChannelGroups is set to true. If a group or one of the group members changes after the initial import, or if a new one was added, then the add-on should call TriggerChannelGroupsUpdate() </dd></dl>
</div></td></tr>
<tr class="memitem:a11390f3c1ccf5981b20dbe44a313badf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#a11390f3c1ccf5981b20dbe44a313badf">GetChannelGroupsAmount</a> (<a class="el" href="../../d9/d67/emu__msvcrt_8h.html#acee5409d1d6b16f3905a59b0db1bd14f">void</a>)</td></tr>
<tr class="separator:a11390f3c1ccf5981b20dbe44a313badf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22095e8a9986ae55b7aec43c593fd99d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#a22095e8a9986ae55b7aec43c593fd99d">GetChannelGroups</a> (<a class="el" href="../../da/d77/_addon_base_8h.html#a8e2f99776bc8f0a43bccbfd988059d6a">ADDON_HANDLE</a> handle, bool bRadio)</td></tr>
<tr class="separator:a22095e8a9986ae55b7aec43c593fd99d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58ee2088f2a64853a46bda1c0b7b9ba5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#a58ee2088f2a64853a46bda1c0b7b9ba5">GetChannelGroupMembers</a> (<a class="el" href="../../da/d77/_addon_base_8h.html#a8e2f99776bc8f0a43bccbfd988059d6a">ADDON_HANDLE</a> handle, const <a class="el" href="../../d2/d0e/struct_p_v_r___c_h_a_n_n_e_l___g_r_o_u_p.html">PVR_CHANNEL_GROUP</a> &amp;<a class="el" href="../../d3/d08/structgroup.html">group</a>)</td></tr>
<tr class="separator:a58ee2088f2a64853a46bda1c0b7b9ba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">PVR channel methods</div></td></tr>
<tr><td colspan="2"><div class="groupText"><dl class="section remark"><dt>Remarks</dt><dd>Either bSupportsTV or bSupportsRadio is required to be set to true. If a channel changes after the initial import, or if a new one was added, then the add-on should call TriggerChannelUpdate() </dd></dl>
</div></td></tr>
<tr class="memitem:a7ac1f5d1a6306aed664793bf839b9fe8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#a7ac1f5d1a6306aed664793bf839b9fe8">OpenDialogChannelScan</a> (<a class="el" href="../../d9/d67/emu__msvcrt_8h.html#acee5409d1d6b16f3905a59b0db1bd14f">void</a>)</td></tr>
<tr class="separator:a7ac1f5d1a6306aed664793bf839b9fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a883a3a26baf8f8e6244d14546432b8da"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#a883a3a26baf8f8e6244d14546432b8da">GetChannelsAmount</a> (<a class="el" href="../../d9/d67/emu__msvcrt_8h.html#acee5409d1d6b16f3905a59b0db1bd14f">void</a>)</td></tr>
<tr class="separator:a883a3a26baf8f8e6244d14546432b8da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dac16d985eab297347f70c03fa77713"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#a3dac16d985eab297347f70c03fa77713">GetChannels</a> (<a class="el" href="../../da/d77/_addon_base_8h.html#a8e2f99776bc8f0a43bccbfd988059d6a">ADDON_HANDLE</a> handle, bool bRadio)</td></tr>
<tr class="separator:a3dac16d985eab297347f70c03fa77713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcdc76aa11f2dca1fa1afe590be76f47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#adcdc76aa11f2dca1fa1afe590be76f47">DeleteChannel</a> (const <a class="el" href="../../d4/d7c/struct_p_v_r___c_h_a_n_n_e_l.html">PVR_CHANNEL</a> &amp;channel)</td></tr>
<tr class="separator:adcdc76aa11f2dca1fa1afe590be76f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac776e40ff6bc7946bc297802bf6487d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#ac776e40ff6bc7946bc297802bf6487d4">RenameChannel</a> (const <a class="el" href="../../d4/d7c/struct_p_v_r___c_h_a_n_n_e_l.html">PVR_CHANNEL</a> &amp;channel)</td></tr>
<tr class="separator:ac776e40ff6bc7946bc297802bf6487d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16e2c4ee1afe60d81cb4fefa10f98cc6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#a16e2c4ee1afe60d81cb4fefa10f98cc6">OpenDialogChannelSettings</a> (const <a class="el" href="../../d4/d7c/struct_p_v_r___c_h_a_n_n_e_l.html">PVR_CHANNEL</a> &amp;channel)</td></tr>
<tr class="separator:a16e2c4ee1afe60d81cb4fefa10f98cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0eb05ecd8b66dd9820a735ea02f4f11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#aa0eb05ecd8b66dd9820a735ea02f4f11">OpenDialogChannelAdd</a> (const <a class="el" href="../../d4/d7c/struct_p_v_r___c_h_a_n_n_e_l.html">PVR_CHANNEL</a> &amp;channel)</td></tr>
<tr class="separator:aa0eb05ecd8b66dd9820a735ea02f4f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">PVR recording methods</div></td></tr>
<tr><td colspan="2"><div class="groupText"><dl class="section remark"><dt>Remarks</dt><dd>Only used by Kodi if bSupportsRecordings is set to true. If a recording changes after the initial import, or if a new one was added, then the add-on should call TriggerRecordingUpdate() </dd></dl>
</div></td></tr>
<tr class="memitem:a7483fce5fadfa74152682420634a16e7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#a7483fce5fadfa74152682420634a16e7">GetRecordingsAmount</a> (bool deleted)</td></tr>
<tr class="separator:a7483fce5fadfa74152682420634a16e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6f11b5464fd68ad226da6ff01518453"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#ad6f11b5464fd68ad226da6ff01518453">GetRecordings</a> (<a class="el" href="../../da/d77/_addon_base_8h.html#a8e2f99776bc8f0a43bccbfd988059d6a">ADDON_HANDLE</a> handle, bool deleted)</td></tr>
<tr class="separator:ad6f11b5464fd68ad226da6ff01518453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aada4fc796e247b7c149ec4ca85713e0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#aada4fc796e247b7c149ec4ca85713e0a">DeleteRecording</a> (const <a class="el" href="../../d8/dbf/struct_p_v_r___r_e_c_o_r_d_i_n_g.html">PVR_RECORDING</a> &amp;recording)</td></tr>
<tr class="separator:aada4fc796e247b7c149ec4ca85713e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a279c22272e7efd2ce928bc7241df4d70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#a279c22272e7efd2ce928bc7241df4d70">UndeleteRecording</a> (const <a class="el" href="../../d8/dbf/struct_p_v_r___r_e_c_o_r_d_i_n_g.html">PVR_RECORDING</a> &amp;recording)</td></tr>
<tr class="separator:a279c22272e7efd2ce928bc7241df4d70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6da8dfcf7dfd645e36789b9cf16f60f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#af6da8dfcf7dfd645e36789b9cf16f60f">DeleteAllRecordingsFromTrash</a> ()</td></tr>
<tr class="memdesc:af6da8dfcf7dfd645e36789b9cf16f60f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete all recordings permanent which in the deleted folder on the backend.  <a href="../../dd/ddf/xbmc__pvr__dll_8h.html#af6da8dfcf7dfd645e36789b9cf16f60f">More...</a><br /></td></tr>
<tr class="separator:af6da8dfcf7dfd645e36789b9cf16f60f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421da11d41cfd4b37832a1eb1acc0c31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#a421da11d41cfd4b37832a1eb1acc0c31">RenameRecording</a> (const <a class="el" href="../../d8/dbf/struct_p_v_r___r_e_c_o_r_d_i_n_g.html">PVR_RECORDING</a> &amp;recording)</td></tr>
<tr class="separator:a421da11d41cfd4b37832a1eb1acc0c31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a704046cf6eda67e5f030f820f3a36200"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#a704046cf6eda67e5f030f820f3a36200">SetRecordingLifetime</a> (const <a class="el" href="../../d8/dbf/struct_p_v_r___r_e_c_o_r_d_i_n_g.html">PVR_RECORDING</a> *recording)</td></tr>
<tr class="separator:a704046cf6eda67e5f030f820f3a36200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b0c5812ed0176a66f551a10a5e2b4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#a52b0c5812ed0176a66f551a10a5e2b4a">SetRecordingPlayCount</a> (const <a class="el" href="../../d8/dbf/struct_p_v_r___r_e_c_o_r_d_i_n_g.html">PVR_RECORDING</a> &amp;recording, int count)</td></tr>
<tr class="separator:a52b0c5812ed0176a66f551a10a5e2b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa41b30092f3c1baf1cb492f51734962a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#aa41b30092f3c1baf1cb492f51734962a">SetRecordingLastPlayedPosition</a> (const <a class="el" href="../../d8/dbf/struct_p_v_r___r_e_c_o_r_d_i_n_g.html">PVR_RECORDING</a> &amp;recording, int lastplayedposition)</td></tr>
<tr class="separator:aa41b30092f3c1baf1cb492f51734962a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac99fd023f619717ee1cf2e0ed83a9557"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#ac99fd023f619717ee1cf2e0ed83a9557">GetRecordingLastPlayedPosition</a> (const <a class="el" href="../../d8/dbf/struct_p_v_r___r_e_c_o_r_d_i_n_g.html">PVR_RECORDING</a> &amp;recording)</td></tr>
<tr class="separator:ac99fd023f619717ee1cf2e0ed83a9557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a216cabfba19ea846de54736d643fb713"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#a216cabfba19ea846de54736d643fb713">GetRecordingEdl</a> (const <a class="el" href="../../d8/dbf/struct_p_v_r___r_e_c_o_r_d_i_n_g.html">PVR_RECORDING</a> &amp;recording, <a class="el" href="../../d2/d9e/struct_p_v_r___e_d_l___e_n_t_r_y.html">PVR_EDL_ENTRY</a> edl[], int *size)</td></tr>
<tr class="separator:a216cabfba19ea846de54736d643fb713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5812c1c0d9f798f1e8c7c32553436d31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#a5812c1c0d9f798f1e8c7c32553436d31">GetTimerTypes</a> (<a class="el" href="../../db/d07/struct_p_v_r___t_i_m_e_r___t_y_p_e.html">PVR_TIMER_TYPE</a> types[], int *typesCount)</td></tr>
<tr class="separator:a5812c1c0d9f798f1e8c7c32553436d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">PVR timer methods</div></td></tr>
<tr><td colspan="2"><div class="groupText"><dl class="section remark"><dt>Remarks</dt><dd>Only used by Kodi if bSupportsTimers is set to true. If a timer changes after the initial import, or if a new one was added, then the add-on should call TriggerTimerUpdate() </dd></dl>
</div></td></tr>
<tr class="memitem:aa1592e3d0d158bbb57f844e8cd5cc300"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#aa1592e3d0d158bbb57f844e8cd5cc300">GetTimersAmount</a> (<a class="el" href="../../d9/d67/emu__msvcrt_8h.html#acee5409d1d6b16f3905a59b0db1bd14f">void</a>)</td></tr>
<tr class="separator:aa1592e3d0d158bbb57f844e8cd5cc300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bfa096d84f39a66a3f06cc7a73fbf99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#a6bfa096d84f39a66a3f06cc7a73fbf99">GetTimers</a> (<a class="el" href="../../da/d77/_addon_base_8h.html#a8e2f99776bc8f0a43bccbfd988059d6a">ADDON_HANDLE</a> handle)</td></tr>
<tr class="separator:a6bfa096d84f39a66a3f06cc7a73fbf99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d5eee3c0ab5fd75a31a84b3905f5a5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#a2d5eee3c0ab5fd75a31a84b3905f5a5d">AddTimer</a> (const <a class="el" href="../../dd/d29/struct_p_v_r___t_i_m_e_r.html">PVR_TIMER</a> &amp;timer)</td></tr>
<tr class="separator:a2d5eee3c0ab5fd75a31a84b3905f5a5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de056e3013a1db7de2b352d480b92c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#a4de056e3013a1db7de2b352d480b92c0">DeleteTimer</a> (const <a class="el" href="../../dd/d29/struct_p_v_r___t_i_m_e_r.html">PVR_TIMER</a> &amp;timer, bool bForceDelete)</td></tr>
<tr class="separator:a4de056e3013a1db7de2b352d480b92c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dcddd0448c76cf6ecf57944294eab1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#a8dcddd0448c76cf6ecf57944294eab1c">UpdateTimer</a> (const <a class="el" href="../../dd/d29/struct_p_v_r___t_i_m_e_r.html">PVR_TIMER</a> &amp;timer)</td></tr>
<tr class="separator:a8dcddd0448c76cf6ecf57944294eab1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">PVR live stream methods, used to open and close a stream to a channel, and optionally perform read operations on the stream</div></td></tr>
<tr class="memitem:a34e16ebfd4dd1ffd54d267ed0fee5926"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#a34e16ebfd4dd1ffd54d267ed0fee5926">OpenLiveStream</a> (const <a class="el" href="../../d4/d7c/struct_p_v_r___c_h_a_n_n_e_l.html">PVR_CHANNEL</a> &amp;channel)</td></tr>
<tr class="separator:a34e16ebfd4dd1ffd54d267ed0fee5926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fd90a3e10a7f29fa19a6eaf88487f5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d67/emu__msvcrt_8h.html#acee5409d1d6b16f3905a59b0db1bd14f">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#a4fd90a3e10a7f29fa19a6eaf88487f5c">CloseLiveStream</a> (<a class="el" href="../../d9/d67/emu__msvcrt_8h.html#acee5409d1d6b16f3905a59b0db1bd14f">void</a>)</td></tr>
<tr class="separator:a4fd90a3e10a7f29fa19a6eaf88487f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0a31f12e57e4184a5c07eb9edff24a6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#af0a31f12e57e4184a5c07eb9edff24a6">ReadLiveStream</a> (unsigned char *pBuffer, unsigned int iBufferSize)</td></tr>
<tr class="separator:af0a31f12e57e4184a5c07eb9edff24a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a682d0504fc5ea4ad43fcce9a792e2235"><td class="memItemLeft" align="right" valign="top">long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#a682d0504fc5ea4ad43fcce9a792e2235">SeekLiveStream</a> (long long iPosition, int iWhence=SEEK_SET)</td></tr>
<tr class="separator:a682d0504fc5ea4ad43fcce9a792e2235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a325f78efd806b9009385a2fba534ed66"><td class="memItemLeft" align="right" valign="top">long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#a325f78efd806b9009385a2fba534ed66">LengthLiveStream</a> (<a class="el" href="../../d9/d67/emu__msvcrt_8h.html#acee5409d1d6b16f3905a59b0db1bd14f">void</a>)</td></tr>
<tr class="separator:a325f78efd806b9009385a2fba534ed66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d00d56e097ce1ccc277456434c91da3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#a2d00d56e097ce1ccc277456434c91da3">SignalStatus</a> (<a class="el" href="../../d6/d6b/struct_p_v_r___s_i_g_n_a_l___s_t_a_t_u_s.html">PVR_SIGNAL_STATUS</a> &amp;signalStatus)</td></tr>
<tr class="separator:a2d00d56e097ce1ccc277456434c91da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a057ccba62b9c878029ebeb463f7b84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#a6a057ccba62b9c878029ebeb463f7b84">GetDescrambleInfo</a> (<a class="el" href="../../d8/d36/struct_p_v_r___d_e_s_c_r_a_m_b_l_e___i_n_f_o.html">PVR_DESCRAMBLE_INFO</a> *descrambleInfo)</td></tr>
<tr class="separator:a6a057ccba62b9c878029ebeb463f7b84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17bed3bfc83ee0fb329aedfe6343c21f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#a17bed3bfc83ee0fb329aedfe6343c21f">GetChannelStreamProperties</a> (const <a class="el" href="../../d4/d7c/struct_p_v_r___c_h_a_n_n_e_l.html">PVR_CHANNEL</a> *channel, <a class="el" href="../../d2/d18/struct_p_v_r___n_a_m_e_d___v_a_l_u_e.html">PVR_NAMED_VALUE</a> *properties, unsigned int *iPropertiesCount)</td></tr>
<tr class="separator:a17bed3bfc83ee0fb329aedfe6343c21f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa709173540f1394182598693e52e9374"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#aa709173540f1394182598693e52e9374">GetRecordingStreamProperties</a> (const <a class="el" href="../../d8/dbf/struct_p_v_r___r_e_c_o_r_d_i_n_g.html">PVR_RECORDING</a> *recording, <a class="el" href="../../d2/d18/struct_p_v_r___n_a_m_e_d___v_a_l_u_e.html">PVR_NAMED_VALUE</a> *properties, unsigned int *iPropertiesCount)</td></tr>
<tr class="separator:aa709173540f1394182598693e52e9374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dbd12115e41104682ad9b380329626d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#a8dbd12115e41104682ad9b380329626d">GetStreamProperties</a> (<a class="el" href="../../d8/d0a/struct_p_v_r___s_t_r_e_a_m___p_r_o_p_e_r_t_i_e_s.html">PVR_STREAM_PROPERTIES</a> *pProperties)</td></tr>
<tr class="separator:a8dbd12115e41104682ad9b380329626d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">PVR recording stream methods, used to open and close a stream to a recording, and perform read operations on the stream.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><dl class="section remark"><dt>Remarks</dt><dd>This will only be used if the backend doesn't provide a direct URL in the recording tag. </dd></dl>
</div></td></tr>
<tr class="memitem:a2f9fe67ca9ac8e3ae44bd3846b1c819d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#a2f9fe67ca9ac8e3ae44bd3846b1c819d">GetStreamReadChunkSize</a> (int *chunksize)</td></tr>
<tr class="separator:a2f9fe67ca9ac8e3ae44bd3846b1c819d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8e34b64d68ed640ceb05ada10e4158b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#af8e34b64d68ed640ceb05ada10e4158b">OpenRecordedStream</a> (const <a class="el" href="../../d8/dbf/struct_p_v_r___r_e_c_o_r_d_i_n_g.html">PVR_RECORDING</a> &amp;recording)</td></tr>
<tr class="separator:af8e34b64d68ed640ceb05ada10e4158b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a485bde72341ec4380c8b58591d4f3628"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d67/emu__msvcrt_8h.html#acee5409d1d6b16f3905a59b0db1bd14f">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#a485bde72341ec4380c8b58591d4f3628">CloseRecordedStream</a> (<a class="el" href="../../d9/d67/emu__msvcrt_8h.html#acee5409d1d6b16f3905a59b0db1bd14f">void</a>)</td></tr>
<tr class="separator:a485bde72341ec4380c8b58591d4f3628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10e954f136a0faff36ba757f419759a1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#a10e954f136a0faff36ba757f419759a1">ReadRecordedStream</a> (unsigned char *pBuffer, unsigned int iBufferSize)</td></tr>
<tr class="separator:a10e954f136a0faff36ba757f419759a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3fd6f7debd84688a73b35fdb765f7bf"><td class="memItemLeft" align="right" valign="top">long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#aa3fd6f7debd84688a73b35fdb765f7bf">SeekRecordedStream</a> (long long iPosition, int iWhence=SEEK_SET)</td></tr>
<tr class="separator:aa3fd6f7debd84688a73b35fdb765f7bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ef7cbfaaa1d04cf0ddd3cd6a3eb695"><td class="memItemLeft" align="right" valign="top">long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#a68ef7cbfaaa1d04cf0ddd3cd6a3eb695">LengthRecordedStream</a> (<a class="el" href="../../d9/d67/emu__msvcrt_8h.html#acee5409d1d6b16f3905a59b0db1bd14f">void</a>)</td></tr>
<tr class="separator:a68ef7cbfaaa1d04cf0ddd3cd6a3eb695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">PVR demultiplexer methods</div></td></tr>
<tr><td colspan="2"><div class="groupText"><dl class="section remark"><dt>Remarks</dt><dd>Only used by Kodi if bHandlesDemuxing is set to true. </dd></dl>
</div></td></tr>
<tr class="memitem:a23ff1629066ecead29fd4d6e5aea81df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d67/emu__msvcrt_8h.html#acee5409d1d6b16f3905a59b0db1bd14f">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#a23ff1629066ecead29fd4d6e5aea81df">DemuxReset</a> (<a class="el" href="../../d9/d67/emu__msvcrt_8h.html#acee5409d1d6b16f3905a59b0db1bd14f">void</a>)</td></tr>
<tr class="separator:a23ff1629066ecead29fd4d6e5aea81df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45aee9823847ec05ffa8c5e6b40a767d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d67/emu__msvcrt_8h.html#acee5409d1d6b16f3905a59b0db1bd14f">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#a45aee9823847ec05ffa8c5e6b40a767d">DemuxAbort</a> (<a class="el" href="../../d9/d67/emu__msvcrt_8h.html#acee5409d1d6b16f3905a59b0db1bd14f">void</a>)</td></tr>
<tr class="separator:a45aee9823847ec05ffa8c5e6b40a767d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa536f2ec63f8666013cab3a9e9879531"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d67/emu__msvcrt_8h.html#acee5409d1d6b16f3905a59b0db1bd14f">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#aa536f2ec63f8666013cab3a9e9879531">DemuxFlush</a> (<a class="el" href="../../d9/d67/emu__msvcrt_8h.html#acee5409d1d6b16f3905a59b0db1bd14f">void</a>)</td></tr>
<tr class="separator:aa536f2ec63f8666013cab3a9e9879531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fd6e731bf4f8ec9b165eefb01c4ae11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d5/d74/struct_demux_packet.html">DemuxPacket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#a1fd6e731bf4f8ec9b165eefb01c4ae11">DemuxRead</a> (<a class="el" href="../../d9/d67/emu__msvcrt_8h.html#acee5409d1d6b16f3905a59b0db1bd14f">void</a>)</td></tr>
<tr class="separator:a1fd6e731bf4f8ec9b165eefb01c4ae11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c242d4428a139d253257a462dcf1c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#ae0c242d4428a139d253257a462dcf1c7">CanPauseStream</a> ()</td></tr>
<tr class="separator:ae0c242d4428a139d253257a462dcf1c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b9bbd339f34d01783f3d798888c45e9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#a8b9bbd339f34d01783f3d798888c45e9">CanSeekStream</a> ()</td></tr>
<tr class="separator:a8b9bbd339f34d01783f3d798888c45e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f43e1e9ed5b0f681b10ab67346f53fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d67/emu__msvcrt_8h.html#acee5409d1d6b16f3905a59b0db1bd14f">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#a5f43e1e9ed5b0f681b10ab67346f53fa">PauseStream</a> (bool bPaused)</td></tr>
<tr class="memdesc:a5f43e1e9ed5b0f681b10ab67346f53fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify the pvr addon that Kodi (un)paused the currently playing stream.  <a href="../../dd/ddf/xbmc__pvr__dll_8h.html#a5f43e1e9ed5b0f681b10ab67346f53fa">More...</a><br /></td></tr>
<tr class="separator:a5f43e1e9ed5b0f681b10ab67346f53fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17901058614e41f10bb1ea52a007735e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#a17901058614e41f10bb1ea52a007735e">SeekTime</a> (double time, bool backwards, double *startpts)</td></tr>
<tr class="separator:a17901058614e41f10bb1ea52a007735e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64be5578c1c726e0d16e64c2554688b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d67/emu__msvcrt_8h.html#acee5409d1d6b16f3905a59b0db1bd14f">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#a64be5578c1c726e0d16e64c2554688b5">SetSpeed</a> (int speed)</td></tr>
<tr class="separator:a64be5578c1c726e0d16e64c2554688b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dc3626094586e0df953ea8452042fdf"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#a4dc3626094586e0df953ea8452042fdf">GetBackendHostname</a> ()</td></tr>
<tr class="separator:a4dc3626094586e0df953ea8452042fdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a72ec51d99448f3135899a9ea16e32e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#a3a72ec51d99448f3135899a9ea16e32e">IsTimeshifting</a> ()</td></tr>
<tr class="separator:a3a72ec51d99448f3135899a9ea16e32e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b8697a63d1a510d419d44d9f75454a5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#a3b8697a63d1a510d419d44d9f75454a5">IsRealTimeStream</a> ()</td></tr>
<tr class="separator:a3b8697a63d1a510d419d44d9f75454a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37a42cac81b5aef12d47e4dbca085b4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#a37a42cac81b5aef12d47e4dbca085b4f">SetEPGTimeFrame</a> (int iDays)</td></tr>
<tr class="separator:a37a42cac81b5aef12d47e4dbca085b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5966d47b3221bbf1a013c5091e7705c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d67/emu__msvcrt_8h.html#acee5409d1d6b16f3905a59b0db1bd14f">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#a5966d47b3221bbf1a013c5091e7705c0">OnSystemSleep</a> ()</td></tr>
<tr class="separator:a5966d47b3221bbf1a013c5091e7705c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5a80f99effeb5fd3e82fe68f933b5f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d67/emu__msvcrt_8h.html#acee5409d1d6b16f3905a59b0db1bd14f">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#ac5a80f99effeb5fd3e82fe68f933b5f0">OnSystemWake</a> ()</td></tr>
<tr class="separator:ac5a80f99effeb5fd3e82fe68f933b5f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cc6a6630e29e8d3d3ecf9b5802c2fa0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d67/emu__msvcrt_8h.html#acee5409d1d6b16f3905a59b0db1bd14f">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#a9cc6a6630e29e8d3d3ecf9b5802c2fa0">OnPowerSavingActivated</a> ()</td></tr>
<tr class="separator:a9cc6a6630e29e8d3d3ecf9b5802c2fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227a0a468e1b54bf42a6b993d65eff20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d67/emu__msvcrt_8h.html#acee5409d1d6b16f3905a59b0db1bd14f">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#a227a0a468e1b54bf42a6b993d65eff20">OnPowerSavingDeactivated</a> ()</td></tr>
<tr class="separator:a227a0a468e1b54bf42a6b993d65eff20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac793e263ee068f27422a875e005f0223"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#ac793e263ee068f27422a875e005f0223">GetStreamTimes</a> (<a class="el" href="../../d6/d1e/struct_p_v_r___s_t_r_e_a_m___t_i_m_e_s.html">PVR_STREAM_TIMES</a> *times)</td></tr>
<tr class="separator:ac793e263ee068f27422a875e005f0223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae2e99db10002140857baa01456a1de9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d67/emu__msvcrt_8h.html#acee5409d1d6b16f3905a59b0db1bd14f">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#aae2e99db10002140857baa01456a1de9">__declspec</a> (dllexport) get_addon(<a class="el" href="../../d9/d67/emu__msvcrt_8h.html#acee5409d1d6b16f3905a59b0db1bd14f">void</a> *ptr)</td></tr>
<tr class="separator:aae2e99db10002140857baa01456a1de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="aae2e99db10002140857baa01456a1de9" name="aae2e99db10002140857baa01456a1de9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae2e99db10002140857baa01456a1de9">&#9670;&nbsp;</a></span>__declspec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d67/emu__msvcrt_8h.html#acee5409d1d6b16f3905a59b0db1bd14f">void</a> __declspec </td>
          <td>(</td>
          <td class="paramtype">dllexport&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Called by Kodi to assign the function pointers of this add-on to pClient. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The struct to assign the function pointers to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2d5eee3c0ab5fd75a31a84b3905f5a5d" name="a2d5eee3c0ab5fd75a31a84b3905f5a5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d5eee3c0ab5fd75a31a84b3905f5a5d">&#9670;&nbsp;</a></span>AddTimer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a> AddTimer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dd/d29/struct_p_v_r___t_i_m_e_r.html">PVR_TIMER</a> &amp;&#160;</td>
          <td class="paramname"><em>timer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Add a timer on the backend. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timer</td><td>The timer to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the timer has been added successfully. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if bSupportsTimers is set to true. Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a id="a98ea5b651445ba01caeca6b411ac33cb" name="a98ea5b651445ba01caeca6b411ac33cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98ea5b651445ba01caeca6b411ac33cb">&#9670;&nbsp;</a></span>CallMenuHook()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a> CallMenuHook </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/d40/struct_p_v_r___m_e_n_u_h_o_o_k.html">PVR_MENUHOOK</a> &amp;&#160;</td>
          <td class="paramname"><em>menuhook</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../db/d43/struct_p_v_r___m_e_n_u_h_o_o_k___d_a_t_a.html">PVR_MENUHOOK_DATA</a> &amp;&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Call one of the menu hooks (if supported). Supported <a class="el" href="../../d4/d40/struct_p_v_r___m_e_n_u_h_o_o_k.html" title="Menu hooks that are available in the context menus while playing a stream via this add-on....">PVR_MENUHOOK</a> instances have to be added in ADDON_Create(), by calling AddMenuHook() on the callback. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">menuhook</td><td>The hook to call. </td></tr>
    <tr><td class="paramname">item</td><td>The selected item for which the hook was called. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the hook was called successfully. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Optional. Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a id="ae0c242d4428a139d253257a462dcf1c7" name="ae0c242d4428a139d253257a462dcf1c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0c242d4428a139d253257a462dcf1c7">&#9670;&nbsp;</a></span>CanPauseStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CanPauseStream </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Check if the backend support pausing the currently playing stream This will enable/disable the pause button in Kodi based on the return value </p><dl class="section return"><dt>Returns</dt><dd>false if the <a class="el" href="../../dc/dc4/namespace_p_v_r.html">PVR</a> addon/backend does not support pausing, true if possible </dd></dl>

</div>
</div>
<a id="a8b9bbd339f34d01783f3d798888c45e9" name="a8b9bbd339f34d01783f3d798888c45e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b9bbd339f34d01783f3d798888c45e9">&#9670;&nbsp;</a></span>CanSeekStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CanSeekStream </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Check if the backend supports seeking for the currently playing stream This will enable/disable the rewind/forward buttons in Kodi based on the return value </p><dl class="section return"><dt>Returns</dt><dd>false if the <a class="el" href="../../dc/dc4/namespace_p_v_r.html">PVR</a> addon/backend does not support seeking, true if possible </dd></dl>

</div>
</div>
<a id="a4fd90a3e10a7f29fa19a6eaf88487f5c" name="a4fd90a3e10a7f29fa19a6eaf88487f5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fd90a3e10a7f29fa19a6eaf88487f5c">&#9670;&nbsp;</a></span>CloseLiveStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d67/emu__msvcrt_8h.html#acee5409d1d6b16f3905a59b0db1bd14f">void</a> CloseLiveStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d67/emu__msvcrt_8h.html#acee5409d1d6b16f3905a59b0db1bd14f">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Close an open live stream. </p><dl class="section remark"><dt>Remarks</dt><dd>Required if bHandlesInputStream or bHandlesDemuxing is set to true. </dd></dl>

</div>
</div>
<a id="a485bde72341ec4380c8b58591d4f3628" name="a485bde72341ec4380c8b58591d4f3628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a485bde72341ec4380c8b58591d4f3628">&#9670;&nbsp;</a></span>CloseRecordedStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d67/emu__msvcrt_8h.html#acee5409d1d6b16f3905a59b0db1bd14f">void</a> CloseRecordedStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d67/emu__msvcrt_8h.html#acee5409d1d6b16f3905a59b0db1bd14f">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Close an open stream from a recording. </p><dl class="section remark"><dt>Remarks</dt><dd>Optional, and only used if bSupportsRecordings is set to true. </dd></dl>

</div>
</div>
<a id="af6da8dfcf7dfd645e36789b9cf16f60f" name="af6da8dfcf7dfd645e36789b9cf16f60f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6da8dfcf7dfd645e36789b9cf16f60f">&#9670;&nbsp;</a></span>DeleteAllRecordingsFromTrash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a> DeleteAllRecordingsFromTrash </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete all recordings permanent which in the deleted folder on the backend. </p>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the recordings has been deleted successfully. </dd></dl>

</div>
</div>
<a id="adcdc76aa11f2dca1fa1afe590be76f47" name="adcdc76aa11f2dca1fa1afe590be76f47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcdc76aa11f2dca1fa1afe590be76f47">&#9670;&nbsp;</a></span>DeleteChannel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a> DeleteChannel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/d7c/struct_p_v_r___c_h_a_n_n_e_l.html">PVR_CHANNEL</a> &amp;&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Delete a channel from the backend. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>The channel to delete. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the channel has been deleted successfully. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if bSupportsChannelSettings is set to true. </dd></dl>

</div>
</div>
<a id="aada4fc796e247b7c149ec4ca85713e0a" name="aada4fc796e247b7c149ec4ca85713e0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aada4fc796e247b7c149ec4ca85713e0a">&#9670;&nbsp;</a></span>DeleteRecording()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a> DeleteRecording </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d8/dbf/struct_p_v_r___r_e_c_o_r_d_i_n_g.html">PVR_RECORDING</a> &amp;&#160;</td>
          <td class="paramname"><em>recording</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Delete a recording on the backend. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recording</td><td>The recording to delete. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the recording has been deleted successfully. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Optional, and only used if bSupportsRecordings is set to true. Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a id="a4de056e3013a1db7de2b352d480b92c0" name="a4de056e3013a1db7de2b352d480b92c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4de056e3013a1db7de2b352d480b92c0">&#9670;&nbsp;</a></span>DeleteTimer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a> DeleteTimer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dd/d29/struct_p_v_r___t_i_m_e_r.html">PVR_TIMER</a> &amp;&#160;</td>
          <td class="paramname"><em>timer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bForceDelete</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Delete a timer on the backend. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timer</td><td>The timer to delete. </td></tr>
    <tr><td class="paramname">bForceDelete</td><td>Set to true to delete a timer that is currently recording a program. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the timer has been deleted successfully. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if bSupportsTimers is set to true. Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a id="a45aee9823847ec05ffa8c5e6b40a767d" name="a45aee9823847ec05ffa8c5e6b40a767d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45aee9823847ec05ffa8c5e6b40a767d">&#9670;&nbsp;</a></span>DemuxAbort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d67/emu__msvcrt_8h.html#acee5409d1d6b16f3905a59b0db1bd14f">void</a> DemuxAbort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d67/emu__msvcrt_8h.html#acee5409d1d6b16f3905a59b0db1bd14f">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Abort the demultiplexer thread in the add-on. </p><dl class="section remark"><dt>Remarks</dt><dd>Required if bHandlesDemuxing is set to true. </dd></dl>

</div>
</div>
<a id="aa536f2ec63f8666013cab3a9e9879531" name="aa536f2ec63f8666013cab3a9e9879531"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa536f2ec63f8666013cab3a9e9879531">&#9670;&nbsp;</a></span>DemuxFlush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d67/emu__msvcrt_8h.html#acee5409d1d6b16f3905a59b0db1bd14f">void</a> DemuxFlush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d67/emu__msvcrt_8h.html#acee5409d1d6b16f3905a59b0db1bd14f">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Flush all data that's currently in the demultiplexer buffer in the add-on. </p><dl class="section remark"><dt>Remarks</dt><dd>Required if bHandlesDemuxing is set to true. </dd></dl>

</div>
</div>
<a id="a1fd6e731bf4f8ec9b165eefb01c4ae11" name="a1fd6e731bf4f8ec9b165eefb01c4ae11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fd6e731bf4f8ec9b165eefb01c4ae11">&#9670;&nbsp;</a></span>DemuxRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/d74/struct_demux_packet.html">DemuxPacket</a> * DemuxRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d67/emu__msvcrt_8h.html#acee5409d1d6b16f3905a59b0db1bd14f">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Read the next packet from the demultiplexer, if there is one. </p><dl class="section return"><dt>Returns</dt><dd>The next packet. If there is no next packet, then the add-on should return the packet created by calling AllocateDemuxPacket(0) on the callback. If the stream changed and Kodi's player needs to be reinitialised, then, the add-on should call AllocateDemuxPacket(0) on the callback, and set the streamid to DMX_SPECIALID_STREAMCHANGE and return the value. The add-on should return NULL if an error occured. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if bHandlesDemuxing is set to true. Return NULL if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a id="a23ff1629066ecead29fd4d6e5aea81df" name="a23ff1629066ecead29fd4d6e5aea81df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23ff1629066ecead29fd4d6e5aea81df">&#9670;&nbsp;</a></span>DemuxReset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d67/emu__msvcrt_8h.html#acee5409d1d6b16f3905a59b0db1bd14f">void</a> DemuxReset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d67/emu__msvcrt_8h.html#acee5409d1d6b16f3905a59b0db1bd14f">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Reset the demultiplexer in the add-on. </p><dl class="section remark"><dt>Remarks</dt><dd>Required if bHandlesDemuxing is set to true. </dd></dl>

</div>
</div>
<a id="aac0ab5d23b401e2baa76c8ab3a031964" name="aac0ab5d23b401e2baa76c8ab3a031964"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac0ab5d23b401e2baa76c8ab3a031964">&#9670;&nbsp;</a></span>GetAddonCapabilities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a> GetAddonCapabilities </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../db/dd7/struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html">PVR_ADDON_CAPABILITIES</a> *&#160;</td>
          <td class="paramname"><em>pCapabilities</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the list of features that this add-on provides. Called by Kodi to query the add-on's capabilities. Used to check which options should be presented in the UI, which methods to call, etc. All capabilities that the add-on supports should be set to true. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCapabilities</td><td>The add-on's capabilities. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the properties were fetched successfully. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Valid implementation required. </dd></dl>

</div>
</div>
<a id="a4dc3626094586e0df953ea8452042fdf" name="a4dc3626094586e0df953ea8452042fdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dc3626094586e0df953ea8452042fdf">&#9670;&nbsp;</a></span>GetBackendHostname()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * GetBackendHostname </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the hostname of the pvr backend server </p><dl class="section return"><dt>Returns</dt><dd>hostname as ip address or alias. If backend does not utilize a server, return empty string. </dd></dl>

</div>
</div>
<a id="a134f4ea0311a2b5a43cf386e26320b87" name="a134f4ea0311a2b5a43cf386e26320b87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a134f4ea0311a2b5a43cf386e26320b87">&#9670;&nbsp;</a></span>GetBackendName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * GetBackendName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d67/emu__msvcrt_8h.html#acee5409d1d6b16f3905a59b0db1bd14f">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The name reported by the backend that will be displayed in the UI. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Valid implementation required. </dd></dl>

</div>
</div>
<a id="a9e3fc6e343eb4007e3c994bfd701891a" name="a9e3fc6e343eb4007e3c994bfd701891a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e3fc6e343eb4007e3c994bfd701891a">&#9670;&nbsp;</a></span>GetBackendVersion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * GetBackendVersion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d67/emu__msvcrt_8h.html#acee5409d1d6b16f3905a59b0db1bd14f">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The version string reported by the backend that will be displayed in the UI. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Valid implementation required. </dd></dl>

</div>
</div>
<a id="a58ee2088f2a64853a46bda1c0b7b9ba5" name="a58ee2088f2a64853a46bda1c0b7b9ba5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58ee2088f2a64853a46bda1c0b7b9ba5">&#9670;&nbsp;</a></span>GetChannelGroupMembers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a> GetChannelGroupMembers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/d77/_addon_base_8h.html#a8e2f99776bc8f0a43bccbfd988059d6a">ADDON_HANDLE</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/d0e/struct_p_v_r___c_h_a_n_n_e_l___g_r_o_u_p.html">PVR_CHANNEL_GROUP</a> &amp;&#160;</td>
          <td class="paramname"><em>group</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Request the list of all group members of a group from the backend if it supports channel groups. Member entries are added to Kodi by calling TransferChannelGroupMember() on the callback. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Handle to pass to the callback method. </td></tr>
    <tr><td class="paramname">group</td><td>The group to get the members for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the list has been fetched successfully. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if bSupportsChannelGroups is set to true. Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a id="a22095e8a9986ae55b7aec43c593fd99d" name="a22095e8a9986ae55b7aec43c593fd99d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22095e8a9986ae55b7aec43c593fd99d">&#9670;&nbsp;</a></span>GetChannelGroups()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a> GetChannelGroups </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/d77/_addon_base_8h.html#a8e2f99776bc8f0a43bccbfd988059d6a">ADDON_HANDLE</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bRadio</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Request the list of all channel groups from the backend if it supports channel groups. Channel group entries are added to Kodi by calling TransferChannelGroup() on the callback. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Handle to pass to the callback method. </td></tr>
    <tr><td class="paramname">bRadio</td><td>True to get the radio channel groups, false to get the TV channel groups. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the list has been fetched successfully. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if bSupportsChannelGroups is set to true. Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a id="a11390f3c1ccf5981b20dbe44a313badf" name="a11390f3c1ccf5981b20dbe44a313badf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11390f3c1ccf5981b20dbe44a313badf">&#9670;&nbsp;</a></span>GetChannelGroupsAmount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GetChannelGroupsAmount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d67/emu__msvcrt_8h.html#acee5409d1d6b16f3905a59b0db1bd14f">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the total amount of channel groups on the backend if it supports channel groups. </p><dl class="section return"><dt>Returns</dt><dd>The amount of channels, or -1 on error. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if bSupportsChannelGroups is set to true. Return -1 if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a id="a3dac16d985eab297347f70c03fa77713" name="a3dac16d985eab297347f70c03fa77713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dac16d985eab297347f70c03fa77713">&#9670;&nbsp;</a></span>GetChannels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a> GetChannels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/d77/_addon_base_8h.html#a8e2f99776bc8f0a43bccbfd988059d6a">ADDON_HANDLE</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bRadio</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Request the list of all channels from the backend. Channel entries are added to Kodi by calling TransferChannelEntry() on the callback. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Handle to pass to the callback method. </td></tr>
    <tr><td class="paramname">bRadio</td><td>True to get the radio channels, false to get the TV channels. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the list has been fetched successfully. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If bSupportsTV is set to true, a valid result set needs to be provided for bRadio = false. If bSupportsRadio is set to true, a valid result set needs to be provided for bRadio = true. At least one of these two must provide a valid result set. </dd></dl>

</div>
</div>
<a id="a883a3a26baf8f8e6244d14546432b8da" name="a883a3a26baf8f8e6244d14546432b8da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a883a3a26baf8f8e6244d14546432b8da">&#9670;&nbsp;</a></span>GetChannelsAmount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GetChannelsAmount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d67/emu__msvcrt_8h.html#acee5409d1d6b16f3905a59b0db1bd14f">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The total amount of channels on the backend, or -1 on error. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Valid implementation required. </dd></dl>

</div>
</div>
<a id="a17bed3bfc83ee0fb329aedfe6343c21f" name="a17bed3bfc83ee0fb329aedfe6343c21f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17bed3bfc83ee0fb329aedfe6343c21f">&#9670;&nbsp;</a></span>GetChannelStreamProperties()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a> GetChannelStreamProperties </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/d7c/struct_p_v_r___c_h_a_n_n_e_l.html">PVR_CHANNEL</a> *&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d2/d18/struct_p_v_r___n_a_m_e_d___v_a_l_u_e.html">PVR_NAMED_VALUE</a> *&#160;</td>
          <td class="paramname"><em>properties</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>iPropertiesCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the stream properties for a channel from the backend. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">channel</td><td>The channel to get the stream properties for. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">properties</td><td>in: an array for the properties to return, out: the properties required to play the stream. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iPropertiesCount</td><td>in: the size of the properties array, out: the number of properties returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the stream is available. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if <a class="el" href="../../db/dd7/struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html#a7f84fee9fcf79f0e4b6e451adc270eb5" title="true if this add-on provides TV channels">PVR_ADDON_CAPABILITIES::bSupportsTV</a> or <a class="el" href="../../db/dd7/struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html#a0773362c8619b43a00d1a732b812d0f6" title="true if this add-on supports radio channels">PVR_ADDON_CAPABILITIES::bSupportsRadio</a> are set to true and <a class="el" href="../../db/dd7/struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html#ac0c6d831026f21aecc2b0d8a2c3ed350" title="true if this add-on provides an input stream. false if Kodi handles the stream.">PVR_ADDON_CAPABILITIES::bHandlesInputStream</a> is set to false. In this case the implementation must fill the property PVR_STREAM_PROPERTY_STREAMURL with the URL Kodi should resolve to playback the channel. Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a id="a4bfc06985e780593bcaadccc4ef58f04" name="a4bfc06985e780593bcaadccc4ef58f04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bfc06985e780593bcaadccc4ef58f04">&#9670;&nbsp;</a></span>GetConnectionString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * GetConnectionString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d67/emu__msvcrt_8h.html#acee5409d1d6b16f3905a59b0db1bd14f">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The connection string reported by the backend that will be displayed in the UI. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Valid implementation required. </dd></dl>

</div>
</div>
<a id="a6a057ccba62b9c878029ebeb463f7b84" name="a6a057ccba62b9c878029ebeb463f7b84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a057ccba62b9c878029ebeb463f7b84">&#9670;&nbsp;</a></span>GetDescrambleInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a> GetDescrambleInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/d36/struct_p_v_r___d_e_s_c_r_a_m_b_l_e___i_n_f_o.html">PVR_DESCRAMBLE_INFO</a> *&#160;</td>
          <td class="paramname"><em>descrambleInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the descramble information of the stream that's currently open. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">descrambleInfo</td><td>The descramble information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the descramble information has been read successfully, false otherwise. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Optional, and only used if <a class="el" href="../../db/dd7/struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html#aa99b21fb0bf3df9d691264071b8f00c1" title="true if the backend supports descramble information for playing channels.">PVR_ADDON_CAPABILITIES::bSupportsDescrambleInfo</a> is set to true. Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a id="aa4ef92c952f4f98fed7031d5c14dafee" name="aa4ef92c952f4f98fed7031d5c14dafee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4ef92c952f4f98fed7031d5c14dafee">&#9670;&nbsp;</a></span>GetDriveSpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a> GetDriveSpace </td>
          <td>(</td>
          <td class="paramtype">long long *&#160;</td>
          <td class="paramname"><em>iTotal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long *&#160;</td>
          <td class="paramname"><em>iUsed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the disk space reported by the backend (if supported). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iTotal</td><td>The total disk space in bytes. </td></tr>
    <tr><td class="paramname">iUsed</td><td>The used disk space in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the drive space has been fetched successfully. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Optional. Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a id="a357fd3786812f4de703de6609d59120e" name="a357fd3786812f4de703de6609d59120e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a357fd3786812f4de703de6609d59120e">&#9670;&nbsp;</a></span>GetEPGForChannel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a> GetEPGForChannel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/d77/_addon_base_8h.html#a8e2f99776bc8f0a43bccbfd988059d6a">ADDON_HANDLE</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d4/d7c/struct_p_v_r___c_h_a_n_n_e_l.html">PVR_CHANNEL</a> &amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>iStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>iEnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Request the EPG for a channel from the backend. EPG entries are added to Kodi by calling TransferEpgEntry() on the callback. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Handle to pass to the callback method. </td></tr>
    <tr><td class="paramname">channel</td><td>The channel to get the EPG table for. </td></tr>
    <tr><td class="paramname">iStart</td><td>Get events after this time (UTC). </td></tr>
    <tr><td class="paramname">iEnd</td><td>Get events before this time (UTC). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the table has been fetched successfully. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if bSupportsEPG is set to true. Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a id="a29d80039472e2fd0c38b7c04561447ba" name="a29d80039472e2fd0c38b7c04561447ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29d80039472e2fd0c38b7c04561447ba">&#9670;&nbsp;</a></span>GetEPGTagEdl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a> GetEPGTagEdl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d91/struct_e_p_g___t_a_g.html">EPG_TAG</a> *&#160;</td>
          <td class="paramname"><em>epgTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d2/d9e/struct_p_v_r___e_d_l___e_n_t_r_y.html">PVR_EDL_ENTRY</a>&#160;</td>
          <td class="paramname"><em>edl</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Retrieve the edit decision list (EDL) of an EPG tag on the backend. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">epgTag</td><td>The EPG tag. </td></tr>
    <tr><td class="paramname">edl</td><td>out: The function has to write the EDL into this array. </td></tr>
    <tr><td class="paramname">size</td><td>in: The maximum size of the EDL, out: the actual size of the EDL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the EDL was successfully read or no EDL exists. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if bSupportsEpgEdl is set to true. Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a id="ace909572aa272c30adcb46d9f64b3157" name="ace909572aa272c30adcb46d9f64b3157"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace909572aa272c30adcb46d9f64b3157">&#9670;&nbsp;</a></span>GetEPGTagStreamProperties()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a> GetEPGTagStreamProperties </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d91/struct_e_p_g___t_a_g.html">EPG_TAG</a> *&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d2/d18/struct_p_v_r___n_a_m_e_d___v_a_l_u_e.html">PVR_NAMED_VALUE</a> *&#160;</td>
          <td class="paramname"><em>properties</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>iPropertiesCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the stream properties for an epg tag from the backend. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>The epg tag to get the stream properties for. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">properties</td><td>in: an array for the properties to return, out: the properties required to play the stream. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iPropertiesCount</td><td>in: the size of the properties array, out: the number of properties returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the stream is available. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if add-on supports playing epg tags. In this case your implementation must fill the property PVR_STREAM_PROPERTY_STREAMURL with the URL Kodi should resolve to playback the epg tag. Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a id="a216cabfba19ea846de54736d643fb713" name="a216cabfba19ea846de54736d643fb713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a216cabfba19ea846de54736d643fb713">&#9670;&nbsp;</a></span>GetRecordingEdl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a> GetRecordingEdl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d8/dbf/struct_p_v_r___r_e_c_o_r_d_i_n_g.html">PVR_RECORDING</a> &amp;&#160;</td>
          <td class="paramname"><em>recording</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d2/d9e/struct_p_v_r___e_d_l___e_n_t_r_y.html">PVR_EDL_ENTRY</a>&#160;</td>
          <td class="paramname"><em>edl</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Retrieve the edit decision list (EDL) of a recording on the backend. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recording</td><td>The recording. </td></tr>
    <tr><td class="paramname">edl</td><td>out: The function has to write the EDL into this array. </td></tr>
    <tr><td class="paramname">size</td><td>in: The maximum size of the EDL, out: the actual size of the EDL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the EDL was successfully read or no EDL exists. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if bSupportsRecordingEdl is set to true. Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a id="ac99fd023f619717ee1cf2e0ed83a9557" name="ac99fd023f619717ee1cf2e0ed83a9557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac99fd023f619717ee1cf2e0ed83a9557">&#9670;&nbsp;</a></span>GetRecordingLastPlayedPosition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GetRecordingLastPlayedPosition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d8/dbf/struct_p_v_r___r_e_c_o_r_d_i_n_g.html">PVR_RECORDING</a> &amp;&#160;</td>
          <td class="paramname"><em>recording</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Retrieve the last watched position of a recording on the backend. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recording</td><td>The recording. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The last watched position in seconds or -1 on error </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if bSupportsRecordingPlayCount is set to true. Return -1 if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a id="ad6f11b5464fd68ad226da6ff01518453" name="ad6f11b5464fd68ad226da6ff01518453"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6f11b5464fd68ad226da6ff01518453">&#9670;&nbsp;</a></span>GetRecordings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a> GetRecordings </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/d77/_addon_base_8h.html#a8e2f99776bc8f0a43bccbfd988059d6a">ADDON_HANDLE</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deleted</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Request the list of all recordings from the backend, if supported. Recording entries are added to Kodi by calling TransferRecordingEntry() on the callback. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Handle to pass to the callback method. </td></tr>
    <tr><td class="paramname">deleted</td><td>if set return deleted recording (called if bSupportsRecordingsUndelete set to true) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the recordings have been fetched successfully. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if bSupportsRecordings is set to true. Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a id="a7483fce5fadfa74152682420634a16e7" name="a7483fce5fadfa74152682420634a16e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7483fce5fadfa74152682420634a16e7">&#9670;&nbsp;</a></span>GetRecordingsAmount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GetRecordingsAmount </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deleted</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The total amount of recordings on the backend or -1 on error. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deleted</td><td>if set return deleted recording (called if bSupportsRecordingsUndelete set to true) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if bSupportsRecordings is set to true. Return -1 if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a id="aa709173540f1394182598693e52e9374" name="aa709173540f1394182598693e52e9374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa709173540f1394182598693e52e9374">&#9670;&nbsp;</a></span>GetRecordingStreamProperties()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a> GetRecordingStreamProperties </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d8/dbf/struct_p_v_r___r_e_c_o_r_d_i_n_g.html">PVR_RECORDING</a> *&#160;</td>
          <td class="paramname"><em>recording</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d2/d18/struct_p_v_r___n_a_m_e_d___v_a_l_u_e.html">PVR_NAMED_VALUE</a> *&#160;</td>
          <td class="paramname"><em>properties</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>iPropertiesCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the stream properties for a recording from the backend. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">recording</td><td>The recording to get the stream properties for. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">properties</td><td>in: an array for the properties to return, out: the properties required to play the stream. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iPropertiesCount</td><td>in: the size of the properties array, out: the number of properties returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the stream is available. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if <a class="el" href="../../db/dd7/struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html#a67fabfdd61c1fe47dcd23ac832f5ee37" title="true if this add-on supports playback of recordings stored on the backend">PVR_ADDON_CAPABILITIES::bSupportsRecordings</a> is set to true and the add-on does not implement recording stream functions (OpenRecordedStream, ...). In this case your implementation must fill the property PVR_STREAM_PROPERTY_STREAMURL with the URL Kodi should resolve to playback the recording. Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a id="a8dbd12115e41104682ad9b380329626d" name="a8dbd12115e41104682ad9b380329626d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dbd12115e41104682ad9b380329626d">&#9670;&nbsp;</a></span>GetStreamProperties()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a> GetStreamProperties </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/d0a/struct_p_v_r___s_t_r_e_a_m___p_r_o_p_e_r_t_i_e_s.html">PVR_STREAM_PROPERTIES</a> *&#160;</td>
          <td class="paramname"><em>pProperties</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the stream properties of the stream that's currently being read. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pProperties</td><td>The properties of the currently playing stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the properties have been fetched successfully. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if bHandlesDemuxing is set to true. Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a id="a2f9fe67ca9ac8e3ae44bd3846b1c819d" name="a2f9fe67ca9ac8e3ae44bd3846b1c819d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f9fe67ca9ac8e3ae44bd3846b1c819d">&#9670;&nbsp;</a></span>GetStreamReadChunkSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a> GetStreamReadChunkSize </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>chunksize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Obtain the chunk size to use when reading streams. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chunksize</td><td>must be filled with the chunk size in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the chunk size has been fetched successfully. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Optional, and only used if not reading from demuxer (=&gt; DemuxRead) and <a class="el" href="../../db/dd7/struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html#a67fabfdd61c1fe47dcd23ac832f5ee37" title="true if this add-on supports playback of recordings stored on the backend">PVR_ADDON_CAPABILITIES::bSupportsRecordings</a> is true (=&gt; ReadRecordedStream) or <a class="el" href="../../db/dd7/struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html#ac0c6d831026f21aecc2b0d8a2c3ed350" title="true if this add-on provides an input stream. false if Kodi handles the stream.">PVR_ADDON_CAPABILITIES::bHandlesInputStream</a> is true (=&gt; ReadLiveStream). Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function. In this case Kodi will decide on the chunk size to use. </dd></dl>

</div>
</div>
<a id="ac793e263ee068f27422a875e005f0223" name="ac793e263ee068f27422a875e005f0223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac793e263ee068f27422a875e005f0223">&#9670;&nbsp;</a></span>GetStreamTimes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a> GetStreamTimes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d6/d1e/struct_p_v_r___s_t_r_e_a_m___t_i_m_e_s.html">PVR_STREAM_TIMES</a> *&#160;</td>
          <td class="paramname"><em>times</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get stream times. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">times</td><td>A pointer to the data to be filled by the implementation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR on success. </dd></dl>

</div>
</div>
<a id="a6bfa096d84f39a66a3f06cc7a73fbf99" name="a6bfa096d84f39a66a3f06cc7a73fbf99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bfa096d84f39a66a3f06cc7a73fbf99">&#9670;&nbsp;</a></span>GetTimers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a> GetTimers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/d77/_addon_base_8h.html#a8e2f99776bc8f0a43bccbfd988059d6a">ADDON_HANDLE</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Request the list of all timers from the backend if supported. Timer entries are added to Kodi by calling TransferTimerEntry() on the callback. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Handle to pass to the callback method. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the list has been fetched successfully. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if bSupportsTimers is set to true. Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a id="aa1592e3d0d158bbb57f844e8cd5cc300" name="aa1592e3d0d158bbb57f844e8cd5cc300"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1592e3d0d158bbb57f844e8cd5cc300">&#9670;&nbsp;</a></span>GetTimersAmount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GetTimersAmount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d67/emu__msvcrt_8h.html#acee5409d1d6b16f3905a59b0db1bd14f">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The total amount of timers on the backend or -1 on error. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if bSupportsTimers is set to true. Return -1 if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a id="a5812c1c0d9f798f1e8c7c32553436d31" name="a5812c1c0d9f798f1e8c7c32553436d31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5812c1c0d9f798f1e8c7c32553436d31">&#9670;&nbsp;</a></span>GetTimerTypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a> GetTimerTypes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../db/d07/struct_p_v_r___t_i_m_e_r___t_y_p_e.html">PVR_TIMER_TYPE</a>&#160;</td>
          <td class="paramname"><em>types</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>typesCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Retrieve the timer types supported by the backend. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">types</td><td>out: The function has to write the definition of the supported timer types into this array. </td></tr>
    <tr><td class="paramname">typesCount</td><td>in: The maximum size of the list, out: the actual size of the list. default: PVR_ADDON_TIMERTYPE_ARRAY_SIZE </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the types were successfully written to the array. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if bSupportsTimers is set to true. Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a id="af09355268dfa3701f266ee35ddb0adb7" name="af09355268dfa3701f266ee35ddb0adb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af09355268dfa3701f266ee35ddb0adb7">&#9670;&nbsp;</a></span>IsEPGTagPlayable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a> IsEPGTagPlayable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d91/struct_e_p_g___t_a_g.html">EPG_TAG</a> *&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>bIsPlayable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeb2d0ede864295ba8255c19243475b3c" name="aeb2d0ede864295ba8255c19243475b3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb2d0ede864295ba8255c19243475b3c">&#9670;&nbsp;</a></span>IsEPGTagRecordable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a> IsEPGTagRecordable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d91/struct_e_p_g___t_a_g.html">EPG_TAG</a> *&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>bIsRecordable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3b8697a63d1a510d419d44d9f75454a5" name="a3b8697a63d1a510d419d44d9f75454a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b8697a63d1a510d419d44d9f75454a5">&#9670;&nbsp;</a></span>IsRealTimeStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IsRealTimeStream </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Check for real-time streaming </p><dl class="section return"><dt>Returns</dt><dd>true if current stream is real-time </dd></dl>

</div>
</div>
<a id="a3a72ec51d99448f3135899a9ea16e32e" name="a3a72ec51d99448f3135899a9ea16e32e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a72ec51d99448f3135899a9ea16e32e">&#9670;&nbsp;</a></span>IsTimeshifting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IsTimeshifting </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Check if timeshift is active </p><dl class="section return"><dt>Returns</dt><dd>true if timeshift is active </dd></dl>

</div>
</div>
<a id="a325f78efd806b9009385a2fba534ed66" name="a325f78efd806b9009385a2fba534ed66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a325f78efd806b9009385a2fba534ed66">&#9670;&nbsp;</a></span>LengthLiveStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long long LengthLiveStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d67/emu__msvcrt_8h.html#acee5409d1d6b16f3905a59b0db1bd14f">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Obtain the length of a live stream. </p><dl class="section return"><dt>Returns</dt><dd>The total length of the stream that's currently being read. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Optional, and only used if bHandlesInputStream is set to true. Return -1 if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a id="a68ef7cbfaaa1d04cf0ddd3cd6a3eb695" name="a68ef7cbfaaa1d04cf0ddd3cd6a3eb695"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68ef7cbfaaa1d04cf0ddd3cd6a3eb695">&#9670;&nbsp;</a></span>LengthRecordedStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long long LengthRecordedStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d67/emu__msvcrt_8h.html#acee5409d1d6b16f3905a59b0db1bd14f">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Obtain the length of a recorded stream. </p><dl class="section return"><dt>Returns</dt><dd>The total length of the stream that's currently being read. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Optional, and only used if bSupportsRecordings is set to true. Return -1 if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a id="a9cc6a6630e29e8d3d3ecf9b5802c2fa0" name="a9cc6a6630e29e8d3d3ecf9b5802c2fa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cc6a6630e29e8d3d3ecf9b5802c2fa0">&#9670;&nbsp;</a></span>OnPowerSavingActivated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d67/emu__msvcrt_8h.html#acee5409d1d6b16f3905a59b0db1bd14f">void</a> OnPowerSavingActivated </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a227a0a468e1b54bf42a6b993d65eff20" name="a227a0a468e1b54bf42a6b993d65eff20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a227a0a468e1b54bf42a6b993d65eff20">&#9670;&nbsp;</a></span>OnPowerSavingDeactivated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d67/emu__msvcrt_8h.html#acee5409d1d6b16f3905a59b0db1bd14f">void</a> OnPowerSavingDeactivated </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5966d47b3221bbf1a013c5091e7705c0" name="a5966d47b3221bbf1a013c5091e7705c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5966d47b3221bbf1a013c5091e7705c0">&#9670;&nbsp;</a></span>OnSystemSleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d67/emu__msvcrt_8h.html#acee5409d1d6b16f3905a59b0db1bd14f">void</a> OnSystemSleep </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Notify the pvr addon for power management events </p>

</div>
</div>
<a id="ac5a80f99effeb5fd3e82fe68f933b5f0" name="ac5a80f99effeb5fd3e82fe68f933b5f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5a80f99effeb5fd3e82fe68f933b5f0">&#9670;&nbsp;</a></span>OnSystemWake()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d67/emu__msvcrt_8h.html#acee5409d1d6b16f3905a59b0db1bd14f">void</a> OnSystemWake </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa0eb05ecd8b66dd9820a735ea02f4f11" name="aa0eb05ecd8b66dd9820a735ea02f4f11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0eb05ecd8b66dd9820a735ea02f4f11">&#9670;&nbsp;</a></span>OpenDialogChannelAdd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a> OpenDialogChannelAdd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/d7c/struct_p_v_r___c_h_a_n_n_e_l.html">PVR_CHANNEL</a> &amp;&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Show the dialog to add a channel on the backend, if supported by the backend. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>The channel to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the channel has been added successfully. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if bSupportsChannelSettings is set to true. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>see <a class="el" href="../../d4/d22/lib_k_o_d_i__guilib_8h.html">libKODI_guilib.h</a> about related parts </dd></dl>

</div>
</div>
<a id="a7ac1f5d1a6306aed664793bf839b9fe8" name="a7ac1f5d1a6306aed664793bf839b9fe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ac1f5d1a6306aed664793bf839b9fe8">&#9670;&nbsp;</a></span>OpenDialogChannelScan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a> OpenDialogChannelScan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d67/emu__msvcrt_8h.html#acee5409d1d6b16f3905a59b0db1bd14f">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Show the channel scan dialog if this backend supports it. </p><dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the dialog was displayed successfully. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if bSupportsChannelScan is set to true. Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>see <a class="el" href="../../d4/d22/lib_k_o_d_i__guilib_8h.html">libKODI_guilib.h</a> about related parts </dd></dl>

</div>
</div>
<a id="a16e2c4ee1afe60d81cb4fefa10f98cc6" name="a16e2c4ee1afe60d81cb4fefa10f98cc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16e2c4ee1afe60d81cb4fefa10f98cc6">&#9670;&nbsp;</a></span>OpenDialogChannelSettings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a> OpenDialogChannelSettings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/d7c/struct_p_v_r___c_h_a_n_n_e_l.html">PVR_CHANNEL</a> &amp;&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Show the channel settings dialog, if supported by the backend. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>The channel to show the dialog for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the dialog has been displayed successfully. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if bSupportsChannelSettings is set to true. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>see <a class="el" href="../../d4/d22/lib_k_o_d_i__guilib_8h.html">libKODI_guilib.h</a> about related parts </dd></dl>

</div>
</div>
<a id="a34e16ebfd4dd1ffd54d267ed0fee5926" name="a34e16ebfd4dd1ffd54d267ed0fee5926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34e16ebfd4dd1ffd54d267ed0fee5926">&#9670;&nbsp;</a></span>OpenLiveStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool OpenLiveStream </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/d7c/struct_p_v_r___c_h_a_n_n_e_l.html">PVR_CHANNEL</a> &amp;&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Open a live stream on the backend. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>The channel to stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the stream has been opened successfully, false otherwise. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if bHandlesInputStream or bHandlesDemuxing is set to true. <a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#a4fd90a3e10a7f29fa19a6eaf88487f5c">CloseLiveStream()</a> will always be called by Kodi prior to calling this function. Return false if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a id="af8e34b64d68ed640ceb05ada10e4158b" name="af8e34b64d68ed640ceb05ada10e4158b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8e34b64d68ed640ceb05ada10e4158b">&#9670;&nbsp;</a></span>OpenRecordedStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool OpenRecordedStream </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d8/dbf/struct_p_v_r___r_e_c_o_r_d_i_n_g.html">PVR_RECORDING</a> &amp;&#160;</td>
          <td class="paramname"><em>recording</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Open a stream to a recording on the backend. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recording</td><td>The recording to open. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the stream has been opened successfully, false otherwise. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Optional, and only used if bSupportsRecordings is set to true. <a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#a485bde72341ec4380c8b58591d4f3628">CloseRecordedStream()</a> will always be called by Kodi prior to calling this function. Return false if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a id="a5f43e1e9ed5b0f681b10ab67346f53fa" name="a5f43e1e9ed5b0f681b10ab67346f53fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f43e1e9ed5b0f681b10ab67346f53fa">&#9670;&nbsp;</a></span>PauseStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d67/emu__msvcrt_8h.html#acee5409d1d6b16f3905a59b0db1bd14f">void</a> PauseStream </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bPaused</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Notify the pvr addon that Kodi (un)paused the currently playing stream. </p>

</div>
</div>
<a id="af0a31f12e57e4184a5c07eb9edff24a6" name="af0a31f12e57e4184a5c07eb9edff24a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0a31f12e57e4184a5c07eb9edff24a6">&#9670;&nbsp;</a></span>ReadLiveStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ReadLiveStream </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>iBufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Read from an open live stream. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuffer</td><td>The buffer to store the data in. </td></tr>
    <tr><td class="paramname">iBufferSize</td><td>The amount of bytes to read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The amount of bytes that were actually read from the stream. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if bHandlesInputStream is set to true. Return -1 if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a id="a10e954f136a0faff36ba757f419759a1" name="a10e954f136a0faff36ba757f419759a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10e954f136a0faff36ba757f419759a1">&#9670;&nbsp;</a></span>ReadRecordedStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ReadRecordedStream </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>iBufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Read from a recording. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuffer</td><td>The buffer to store the data in. </td></tr>
    <tr><td class="paramname">iBufferSize</td><td>The amount of bytes to read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The amount of bytes that were actually read from the stream. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Optional, and only used if bSupportsRecordings is set to true, but required if <a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html#af8e34b64d68ed640ceb05ada10e4158b">OpenRecordedStream()</a> is implemented. Return -1 if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a id="ac776e40ff6bc7946bc297802bf6487d4" name="ac776e40ff6bc7946bc297802bf6487d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac776e40ff6bc7946bc297802bf6487d4">&#9670;&nbsp;</a></span>RenameChannel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a> RenameChannel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/d7c/struct_p_v_r___c_h_a_n_n_e_l.html">PVR_CHANNEL</a> &amp;&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Rename a channel on the backend. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>The channel to rename, containing the new channel name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the channel has been renamed successfully. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Optional, and only used if bSupportsChannelSettings is set to true. Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a id="a421da11d41cfd4b37832a1eb1acc0c31" name="a421da11d41cfd4b37832a1eb1acc0c31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a421da11d41cfd4b37832a1eb1acc0c31">&#9670;&nbsp;</a></span>RenameRecording()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a> RenameRecording </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d8/dbf/struct_p_v_r___r_e_c_o_r_d_i_n_g.html">PVR_RECORDING</a> &amp;&#160;</td>
          <td class="paramname"><em>recording</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Rename a recording on the backend. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recording</td><td>The recording to rename, containing the new name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the recording has been renamed successfully. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Optional, and only used if bSupportsRecordings is set to true. Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a id="a682d0504fc5ea4ad43fcce9a792e2235" name="a682d0504fc5ea4ad43fcce9a792e2235"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a682d0504fc5ea4ad43fcce9a792e2235">&#9670;&nbsp;</a></span>SeekLiveStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long long SeekLiveStream </td>
          <td>(</td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>iPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iWhence</em> = <code>SEEK_SET</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Seek in a live stream on a backend that supports timeshifting. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iPosition</td><td>The position to seek to. </td></tr>
    <tr><td class="paramname">iWhence</td><td>? </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new position. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Optional, and only used if bHandlesInputStream is set to true. Return -1 if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a id="aa3fd6f7debd84688a73b35fdb765f7bf" name="aa3fd6f7debd84688a73b35fdb765f7bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3fd6f7debd84688a73b35fdb765f7bf">&#9670;&nbsp;</a></span>SeekRecordedStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long long SeekRecordedStream </td>
          <td>(</td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>iPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iWhence</em> = <code>SEEK_SET</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Seek in a recorded stream. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iPosition</td><td>The position to seek to. </td></tr>
    <tr><td class="paramname">iWhence</td><td>? </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new position. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Optional, and only used if bSupportsRecordings is set to true. Return -1 if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a id="a17901058614e41f10bb1ea52a007735e" name="a17901058614e41f10bb1ea52a007735e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17901058614e41f10bb1ea52a007735e">&#9670;&nbsp;</a></span>SeekTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SeekTime </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>backwards</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>startpts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Notify the pvr addon/demuxer that Kodi wishes to seek the stream by time </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>The absolute time since stream start </td></tr>
    <tr><td class="paramname">backwards</td><td>True to seek to keyframe BEFORE time, else AFTER </td></tr>
    <tr><td class="paramname">startpts</td><td>can be updated to point to where display should start </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the seek operation was possible </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Optional, and only used if addon has its own demuxer. Return False if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a id="a37a42cac81b5aef12d47e4dbca085b4f" name="a37a42cac81b5aef12d47e4dbca085b4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37a42cac81b5aef12d47e4dbca085b4f">&#9670;&nbsp;</a></span>SetEPGTimeFrame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a> SetEPGTimeFrame </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iDays</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Tell the client the time frame to use when notifying epg events back to Kodi. The client might push epg events asynchronously to Kodi using the callback function EpgEventStateChange. To be able to only push events that are actually of interest for Kodi, client needs to know about the epg time frame Kodi uses. Kodi supplies the current epg time frame value in <a class="el" href="../../dd/de5/struct_p_v_r___p_r_o_p_e_r_t_i_e_s.html#ab1c6898063115340e22c2d4b2a7c9900" title="if &gt; EPG_TIMEFRAME_UNLIMITED, in async epg mode, deliver only events in the range from &#39;end time &gt; no...">PVR_PROPERTIES.iEpgMaxDays</a> when creating the addon and calls SetEPGTimeFrame later whenever Kodi's epg time frame value changes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iDays</td><td>number of days from "now". EPG_TIMEFRAME_UNLIMITED means that Kodi is interested in all epg events, regardless of event times. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if new value was successfully set. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if bSupportsEPG is set to true. Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a id="aa41b30092f3c1baf1cb492f51734962a" name="aa41b30092f3c1baf1cb492f51734962a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa41b30092f3c1baf1cb492f51734962a">&#9670;&nbsp;</a></span>SetRecordingLastPlayedPosition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a> SetRecordingLastPlayedPosition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d8/dbf/struct_p_v_r___r_e_c_o_r_d_i_n_g.html">PVR_RECORDING</a> &amp;&#160;</td>
          <td class="paramname"><em>recording</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lastplayedposition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Set the last watched position of a recording on the backend. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recording</td><td>The recording. </td></tr>
    <tr><td class="paramname">lastplayedposition</td><td>The last watched position in seconds </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the position has been stored successfully. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if bSupportsLastPlayedPosition is set to true. Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a id="a704046cf6eda67e5f030f820f3a36200" name="a704046cf6eda67e5f030f820f3a36200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a704046cf6eda67e5f030f820f3a36200">&#9670;&nbsp;</a></span>SetRecordingLifetime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a> SetRecordingLifetime </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d8/dbf/struct_p_v_r___r_e_c_o_r_d_i_n_g.html">PVR_RECORDING</a> *&#160;</td>
          <td class="paramname"><em>recording</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Set the lifetime of a recording on the backend. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recording</td><td>The recording to change the lifetime for. recording.iLifetime contains the new lieftime value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the recording's lifetime has been set successfully. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if bSupportsRecordingsLifetimeChange is set to true. Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a id="a52b0c5812ed0176a66f551a10a5e2b4a" name="a52b0c5812ed0176a66f551a10a5e2b4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52b0c5812ed0176a66f551a10a5e2b4a">&#9670;&nbsp;</a></span>SetRecordingPlayCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a> SetRecordingPlayCount </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d8/dbf/struct_p_v_r___r_e_c_o_r_d_i_n_g.html">PVR_RECORDING</a> &amp;&#160;</td>
          <td class="paramname"><em>recording</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Set the play count of a recording on the backend. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recording</td><td>The recording to change the play count. </td></tr>
    <tr><td class="paramname">count</td><td>Play count. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the recording's play count has been set successfully. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if bSupportsRecordingPlayCount is set to true. Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a id="a64be5578c1c726e0d16e64c2554688b5" name="a64be5578c1c726e0d16e64c2554688b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64be5578c1c726e0d16e64c2554688b5">&#9670;&nbsp;</a></span>SetSpeed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d67/emu__msvcrt_8h.html#acee5409d1d6b16f3905a59b0db1bd14f">void</a> SetSpeed </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>speed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Notify the pvr addon/demuxer that Kodi wishes to change playback speed </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">speed</td><td>The requested playback speed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Optional, and only used if addon has its own demuxer. </dd></dl>

</div>
</div>
<a id="a2d00d56e097ce1ccc277456434c91da3" name="a2d00d56e097ce1ccc277456434c91da3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d00d56e097ce1ccc277456434c91da3">&#9670;&nbsp;</a></span>SignalStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a> SignalStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d6/d6b/struct_p_v_r___s_i_g_n_a_l___s_t_a_t_u_s.html">PVR_SIGNAL_STATUS</a> &amp;&#160;</td>
          <td class="paramname"><em>signalStatus</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the signal status of the stream that's currently open. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">signalStatus</td><td>The signal status. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the signal status has been read successfully, false otherwise. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Optional, and only used if <a class="el" href="../../db/dd7/struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html#ac0c6d831026f21aecc2b0d8a2c3ed350" title="true if this add-on provides an input stream. false if Kodi handles the stream.">PVR_ADDON_CAPABILITIES::bHandlesInputStream</a> or <a class="el" href="../../db/dd7/struct_p_v_r___a_d_d_o_n___c_a_p_a_b_i_l_i_t_i_e_s.html#ab7c5964953e0c9e41de96e6ffcc5390a" title="true if this add-on demultiplexes packets.">PVR_ADDON_CAPABILITIES::bHandlesDemuxing</a> is set to true. Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a id="a279c22272e7efd2ce928bc7241df4d70" name="a279c22272e7efd2ce928bc7241df4d70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a279c22272e7efd2ce928bc7241df4d70">&#9670;&nbsp;</a></span>UndeleteRecording()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a> UndeleteRecording </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d8/dbf/struct_p_v_r___r_e_c_o_r_d_i_n_g.html">PVR_RECORDING</a> &amp;&#160;</td>
          <td class="paramname"><em>recording</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Undelete a recording on the backend. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">recording</td><td>The recording to undelete. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the recording has been undeleted successfully. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Optional, and only used if bSupportsRecordingsUndelete is set to true. Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function. </dd></dl>

</div>
</div>
<a id="a8dcddd0448c76cf6ecf57944294eab1c" name="a8dcddd0448c76cf6ecf57944294eab1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dcddd0448c76cf6ecf57944294eab1c">&#9670;&nbsp;</a></span>UpdateTimer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/dba/xbmc__pvr__types_8h.html#a4cf1fba691fffe5b92e8f27159673894">PVR_ERROR</a> UpdateTimer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dd/d29/struct_p_v_r___t_i_m_e_r.html">PVR_TIMER</a> &amp;&#160;</td>
          <td class="paramname"><em>timer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Update the timer information on the backend. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timer</td><td>The timer to update. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PVR_ERROR_NO_ERROR if the timer has been updated successfully. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Required if bSupportsTimers is set to true. Return PVR_ERROR_NOT_IMPLEMENTED if this add-on won't provide this function. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../dir_cac54cf26e505c84e329fbef0b194b02.html">xbmc</a></li><li class="navelem"><a class="el" href="../../dir_4c79dcf003097cda640e8bb1016a11ea.html">addons</a></li><li class="navelem"><a class="el" href="../../dir_1b99761d0b44fd6552e994f67278ba8d.html">kodi-addon-dev-kit</a></li><li class="navelem"><a class="el" href="../../dir_417a2be0c703372bef72d21c17ad7704.html">include</a></li><li class="navelem"><a class="el" href="../../dir_7634b8811587c1aba1020e9b1cc54725.html">kodi</a></li><li class="navelem"><a class="el" href="../../dd/ddf/xbmc__pvr__dll_8h.html">xbmc_pvr_dll.h</a></li>
    <li class="footer">Generated on Sun Dec 19 2021 10:06:29 for Kodi Documentation by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2 </li>
  </ul>
</div>
</body>
</html>
